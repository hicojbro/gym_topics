{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 8, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/src/client/compat/router.ts"],"sourcesContent":["import { useContext } from 'react'\nimport { RouterContext } from '../../shared/lib/router-context.shared-runtime'\nimport type { NextRouter } from '../router'\n\n/**\n * useRouter from `next/compat/router` is designed to assist developers\n * migrating from `pages/` to `app/`. Unlike `next/router`, this hook does not\n * throw when the `NextRouter` is not mounted, and instead returns `null`. The\n * more concrete return type here lets developers use this hook within\n * components that could be shared between both `app/` and `pages/` and handle\n * to the case where the router is not mounted.\n *\n * @returns The `NextRouter` instance if it's available, otherwise `null`.\n */\nexport function useRouter(): NextRouter | null {\n  return useContext(RouterContext)\n}\n"],"names":["useRouter","useContext","RouterContext"],"mappings":";;;;+BAcgBA,aAAAA;;;eAAAA;;;;;AAAT,SAASA;IACd,OAAOC,CAAAA,GAAAA,OAAAA,UAAU,EAACC,4BAAAA,aAAa;AACjC"}},
    {"offset": {"line": 30, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/compat/router.js"],"sourcesContent":["module.exports = require('../dist/client/compat/router')\n"],"names":[],"mappings":"AAAA,OAAO,OAAO"}},
    {"offset": {"line": 35, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@clerk/nextjs/src/client-boundary/hooks/usePagesRouter.tsx"],"sourcesContent":["import { useRouter } from 'next/compat/router';\n\nexport const usePagesRouter = () => {\n  // The compat version of useRouter returns null instead of throwing an error\n  // when used inside app router instead of pages router\n  // we use it to detect if the component is used inside pages or app router\n  // so we can use the correct algorithm to get the path\n  return { pagesRouter: useRouter() };\n};\n"],"names":[],"mappings":";;;;;;AAEO,MAAM,iBAAiB;IAK5B,OAAO;QAAE,aAAa,CAAA,GAAA,wIAAA,CAAA,YAAA;IAAY;AACpC"}},
    {"offset": {"line": 53, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@clerk/nextjs/src/client-boundary/hooks/useEnforceCatchAllRoute.tsx"],"sourcesContent":["import { isProductionEnvironment } from '@clerk/shared';\nimport type { RoutingStrategy } from '@clerk/types';\nimport React from 'react';\n\nimport { useSession } from '../hooks';\nimport { usePagesRouter } from './usePagesRouter';\n\n/**\n * This ugly hook  enforces that the Clerk components are mounted in a catch-all route\n * For pages router, we can parse the pathname we get from the useRouter hook\n * For app router, there is no reliable way to do the same check right now, so we\n * fire a request to a path under window.location.href and we check whether the path\n * exists or not\n */\nexport const useEnforceCatchAllRoute = (\n  component: string,\n  path: string,\n  routing?: RoutingStrategy,\n  requireSessionBeforeCheck = true,\n) => {\n  const ref = React.useRef(0);\n  const { pagesRouter } = usePagesRouter();\n  const { session, isLoaded } = useSession();\n\n  // This check does not break the rules of hooks\n  // as the condition will remain the same for the whole app lifecycle\n  if (isProductionEnvironment()) {\n    return;\n  }\n\n  React.useEffect(() => {\n    if (!isLoaded || (routing && routing !== 'path')) {\n      return;\n    }\n\n    // For components that require an active session, like UserProfile\n    // we should not enforce the catch-all route if there is no session\n    // because these components are usually protected by the middleware\n    // and if the check runs before the session is available, it will fail\n    // even if the route is a catch-all route, as the check request will result\n    // in a 404 because of auth().protect();\n    if (requireSessionBeforeCheck && !session) {\n      return;\n    }\n\n    const ac = new AbortController();\n    const error = () => {\n      const correctPath = pagesRouter ? `${path}/[[...index]].tsx` : `${path}/[[...rest]]/page.tsx`;\n      throw new Error(\n        `\nClerk: The <${component}/> component is not configured correctly. The most likely reasons for this error are:\n\n1. The \"${path}\" route is not a catch-all route.\nIt is recommended to convert this route to a catch-all route, eg: \"${correctPath}\". Alternatively, you can update the <${component}/> component to use hash-based routing by setting the \"routing\" prop to \"hash\".\n\n2. The <${component}/> component is mounted in a catch-all route, but all routes under \"${path}\" are protected by the middleware.\nTo resolve this, ensure that the middleware does not protect the catch-all route or any of its children. If you are using the \"createRouteMatcher\" helper, consider adding \"(.*)\" to the end of the route pattern, eg: \"${path}(.*)\". For more information, see: https://clerk.com/docs/references/nextjs/clerk-middleware#create-route-matcher\n`,\n      );\n    };\n\n    if (pagesRouter) {\n      if (!pagesRouter.pathname.match(/\\[\\[\\.\\.\\..+]]/)) {\n        error();\n      }\n    } else {\n      const check = async () => {\n        // make sure to run this as soon as possible\n        // but don't run again when strict mode is enabled\n        ref.current++;\n        if (ref.current > 1) {\n          return;\n        }\n        let res;\n        try {\n          const url = `${window.location.origin}${\n            window.location.pathname\n          }/${component}_clerk_catchall_check_${Date.now()}`;\n          res = await fetch(url, { signal: ac.signal });\n        } catch (e) {\n          // no op\n        }\n        if (res?.status === 404) {\n          error();\n        }\n      };\n      void check();\n    }\n\n    return () => {\n      // make sure to run this as soon as possible\n      // but don't run again when strict mode is enabled\n      if (ref.current > 1) {\n        ac.abort();\n      }\n    };\n  }, [isLoaded]);\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;AAcO,MAAM,0BAA0B,CACrC,WACA,MACA,SACA,4BAA4B,IAAA;IAE5B,MAAM,MAAM,+MAAA,CAAA,UAAA,CAAM,MAAA,CAAO;IACzB,MAAM,EAAE,WAAA,EAAY,GAAI,CAAA,GAAA,iMAAA,CAAA,iBAAA;IACxB,MAAM,EAAE,OAAA,EAAS,QAAA,EAAS,GAAI,CAAA,GAAA,4JAAA,CAAA,aAAA;IAI9B,IAAI,CAAA,GAAA,+JAAA,CAAA,0BAAA,KAA2B;QAC7B;IACF;IAEA,+MAAA,CAAA,UAAA,CAAM,SAAA,CAAU;QACd,IAAI,CAAC,YAAa,WAAW,YAAY,QAAS;YAChD;QACF;QAQA,IAAI,6BAA6B,CAAC,SAAS;YACzC;QACF;QAEA,MAAM,KAAK,IAAI;QACf,MAAM,QAAQ;YACZ,MAAM,cAAc,cAAc,CAAA,EAAG,KAAI,iBAAA,CAAA,GAAsB,CAAA,EAAG,KAAI,qBAAA,CAAA;YACtE,MAAM,IAAI,MACR,CAAA;YAAA,EACM,UAAS;;QAAA,EAEb,KAAI;mEAAA,EACuD,YAAW,sCAAA,EAAyC,UAAS;;QAAA,EAExH,UAAS,oEAAA,EAAuE,KAAI;wNAAA,EAC4H,KAAI;AAAA,CAAA;QAG1N;QAEA,IAAI,aAAa;YACf,IAAI,CAAC,YAAY,QAAA,CAAS,KAAA,CAAM,mBAAmB;gBACjD;YACF;QACF,OAAO;YACL,MAAM,QAAQ;gBAGZ,IAAI,OAAA;gBACJ,IAAI,IAAI,OAAA,GAAU,GAAG;oBACnB;gBACF;gBACA,IAAI;gBACJ,IAAI;oBACF,MAAM,MAAM,CAAA,EAAG,OAAO,QAAA,CAAS,MAAM,CAAA,EACnC,OAAO,QAAA,CAAS,QAClB,CAAA,CAAA,EAAI,UAAS,sBAAA,EAAyB,KAAK,GAAA,GAAK,CAAA;oBAChD,MAAM,MAAM,MAAM,KAAK;wBAAE,QAAQ,GAAG,MAAA;oBAAO;gBAC7C,EAAA,OAAS,GAAG,CAEZ;gBACA,IAAA,CAAI,OAAA,OAAA,KAAA,IAAA,IAAK,MAAA,MAAW,KAAK;oBACvB;gBACF;YACF;YACA,KAAK;QACP;QAEA,OAAO;YAGL,IAAI,IAAI,OAAA,GAAU,GAAG;gBACnB,GAAG,KAAA;YACL;QACF;IACF,GAAG;QAAC;KAAS;AACf"}},
    {"offset": {"line": 132, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 137, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@clerk/nextjs/src/client-boundary/hooks/usePathnameWithoutCatchAll.tsx"],"sourcesContent":["import React from 'react';\n\nimport { usePagesRouter } from './usePagesRouter';\n\nexport const usePathnameWithoutCatchAll = () => {\n  const pathRef = React.useRef<string>();\n\n  const { pagesRouter } = usePagesRouter();\n\n  if (pagesRouter) {\n    if (pathRef.current) {\n      return pathRef.current;\n    } else {\n      // in pages router things are simpler as the pathname includes the catch all route\n      // which starts with [[... and we can just remove it\n      pathRef.current = pagesRouter.pathname.replace(/\\/\\[\\[\\.\\.\\..*/, '');\n      return pathRef.current;\n    }\n  }\n\n  // require is used to avoid importing next/navigation when the pages router is used,\n  // as it will throw an error. We cannot use dynamic import as it is async\n  // and we need the hook to be sync\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const usePathname = require('next/navigation').usePathname;\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const useParams = require('next/navigation').useParams;\n\n  // Get the pathname that includes any named or catch all params\n  // eg:\n  // the filesystem route /user/[id]/profile/[[...rest]]/page.tsx\n  // could give us the following pathname /user/123/profile/security\n  // if the user navigates to the security section of the user profile\n  const pathname = usePathname() || '';\n  const pathParts = pathname.split('/').filter(Boolean);\n  // the useParams hook returns an object with all named and catch all params\n  // for named params, the key in the returned object always contains a single value\n  // for catch all params, the key in the returned object contains an array of values\n  // we find the catch all params by checking if the value is an array\n  // and then we remove one path part for each catch all param\n  const catchAllParams = Object.values(useParams() || {})\n    .filter(v => Array.isArray(v))\n    .flat(Infinity);\n  // so we end up with the pathname where the components are mounted at\n  // eg /user/123/profile/security will return /user/123/profile as the path\n  if (pathRef.current) {\n    return pathRef.current;\n  } else {\n    pathRef.current = `/${pathParts.slice(0, pathParts.length - catchAllParams.length).join('/')}`;\n    return pathRef.current;\n  }\n};\n"],"names":[],"mappings":";;;;;;;;AAIO,MAAM,6BAA6B;IACxC,MAAM,UAAU,+MAAA,CAAA,UAAA,CAAM,MAAA;IAEtB,MAAM,EAAE,WAAA,EAAY,GAAI,CAAA,GAAA,iMAAA,CAAA,iBAAA;IAExB,IAAI,aAAa;QACf,IAAI,QAAQ,OAAA,EAAS;YACnB,OAAO,QAAQ,OAAA;QACjB,OAAO;YAGL,QAAQ,OAAA,GAAU,YAAY,QAAA,CAAS,OAAA,CAAQ,kBAAkB;YACjE,OAAO,QAAQ,OAAA;QACjB;IACF;IAMA,MAAM,cAAc,0FAA2B,WAAA;IAE/C,MAAM,YAAY,0FAA2B,SAAA;IAO7C,MAAM,WAAW,iBAAiB;IAClC,MAAM,YAAY,SAAS,KAAA,CAAM,KAAK,MAAA,CAAO;IAM7C,MAAM,iBAAiB,OAAO,MAAA,CAAO,eAAe,CAAC,GAClD,MAAA,CAAO,CAAA,IAAK,MAAM,OAAA,CAAQ,IAC1B,IAAA,CAAK;IAGR,IAAI,QAAQ,OAAA,EAAS;QACnB,OAAO,QAAQ,OAAA;IACjB,OAAO;QACL,QAAQ,OAAA,GAAU,CAAA,CAAA,EAAI,UAAU,KAAA,CAAM,GAAG,UAAU,MAAA,GAAS,eAAe,MAAM,EAAE,IAAA,CAAK,KAAI,CAAA;QAC5F,OAAO,QAAQ,OAAA;IACjB;AACF"}},
    {"offset": {"line": 170, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 175, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@clerk/nextjs/src/client-boundary/hooks/useEnforceRoutingProps.tsx"],"sourcesContent":["import { useRoutingProps } from '@clerk/clerk-react/internal';\nimport type { RoutingOptions } from '@clerk/types';\n\nimport { useEnforceCatchAllRoute } from './useEnforceCatchAllRoute';\nimport { usePathnameWithoutCatchAll } from './usePathnameWithoutCatchAll';\n\nexport function useEnforceCorrectRoutingProps<T extends RoutingOptions>(\n  componentName: string,\n  props: T,\n  requireSessionBeforeCheck = true,\n): T {\n  const path = usePathnameWithoutCatchAll();\n  const routingProps = useRoutingProps(componentName, props, { path });\n  useEnforceCatchAllRoute(componentName, path, routingProps.routing, requireSessionBeforeCheck);\n  return routingProps;\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAMO,SAAS,8BACd,aAAA,EACA,KAAA,EACA,4BAA4B,IAAA;IAE5B,MAAM,OAAO,CAAA,GAAA,6MAAA,CAAA,6BAAA;IACb,MAAM,eAAe,CAAA,GAAA,8KAAA,CAAA,kBAAA,EAAgB,eAAe,OAAO;QAAE;IAAK;IAClE,CAAA,GAAA,0MAAA,CAAA,0BAAA,EAAwB,eAAe,MAAM,aAAa,OAAA,EAAS;IACnE,OAAO;AACT"}},
    {"offset": {"line": 196, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 201, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/@clerk/nextjs/src/client-boundary/uiComponents.tsx"],"sourcesContent":["'use client';\n\nimport {\n  CreateOrganization as BaseCreateOrganization,\n  OrganizationProfile as BaseOrganizationProfile,\n  SignIn as BaseSignIn,\n  SignUp as BaseSignUp,\n  UserProfile as BaseUserProfile,\n} from '@clerk/clerk-react';\nimport type {\n  CreateOrganizationProps,\n  OrganizationProfileProps,\n  SignInProps,\n  SignUpProps,\n  UserProfileProps,\n} from '@clerk/types';\nimport React from 'react';\n\nimport { useEnforceCorrectRoutingProps } from './hooks/useEnforceRoutingProps';\n\nexport {\n  OrganizationList,\n  OrganizationSwitcher,\n  SignInButton,\n  SignInWithMetamaskButton,\n  SignOutButton,\n  SignUpButton,\n  UserButton,\n  GoogleOneTap,\n} from '@clerk/clerk-react';\n\n// The assignment of UserProfile with BaseUserProfile props is used\n// to support the CustomPage functionality (eg UserProfile.Page)\n// Also the `typeof BaseUserProfile` is used to resolve the following error:\n// \"The inferred type of 'UserProfile' cannot be named without a reference to ...\"\nexport const UserProfile: typeof BaseUserProfile = Object.assign(\n  (props: UserProfileProps) => {\n    return <BaseUserProfile {...useEnforceCorrectRoutingProps('UserProfile', props)} />;\n  },\n  { ...BaseUserProfile },\n);\n\nexport const CreateOrganization = (props: CreateOrganizationProps) => {\n  return <BaseCreateOrganization {...useEnforceCorrectRoutingProps('CreateOrganization', props)} />;\n};\n\n// The assignment of OrganizationProfile with BaseOrganizationProfile props is used\n// to support the CustomPage functionality (eg OrganizationProfile.Page)\n// Also the `typeof BaseOrganizationProfile` is used to resolved the following error:\n// \"The inferred type of 'OrganizationProfile' cannot be named without a reference to ...\"\nexport const OrganizationProfile: typeof BaseOrganizationProfile = Object.assign(\n  (props: OrganizationProfileProps) => {\n    return <BaseOrganizationProfile {...useEnforceCorrectRoutingProps('OrganizationProfile', props)} />;\n  },\n  { ...BaseOrganizationProfile },\n);\n\nexport const SignIn = (props: SignInProps) => {\n  return <BaseSignIn {...useEnforceCorrectRoutingProps('SignIn', props, false)} />;\n};\n\nexport const SignUp = (props: SignUpProps) => {\n  return <BaseSignUp {...useEnforceCorrectRoutingProps('SignUp', props, false)} />;\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAmCO,MAAM,cAAsC,OAAO,MAAA,CACxD,CAAC;IACC,OAAO,aAAA,GAAA,+MAAA,CAAA,UAAA,CAAA,aAAA,CAAC,2KAAA,CAAA,cAAA,EAAA;QAAiB,GAAG,CAAA,GAAA,yMAAA,CAAA,gCAAA,EAA8B,eAAe,MAAK;IAAA;AAChF,GACA;IAAE,GAAG,2KAAA,CAAA,cAAA;AAAgB;AAGhB,MAAM,qBAAqB,CAAC;IACjC,OAAO,aAAA,GAAA,+MAAA,CAAA,UAAA,CAAA,aAAA,CAAC,2KAAA,CAAA,qBAAA,EAAA;QAAwB,GAAG,CAAA,GAAA,yMAAA,CAAA,gCAAA,EAA8B,sBAAsB,MAAK;IAAA;AAC9F;AAMO,MAAM,sBAAsD,OAAO,MAAA,CACxE,CAAC;IACC,OAAO,aAAA,GAAA,+MAAA,CAAA,UAAA,CAAA,aAAA,CAAC,2KAAA,CAAA,sBAAA,EAAA;QAAyB,GAAG,CAAA,GAAA,yMAAA,CAAA,gCAAA,EAA8B,uBAAuB,MAAK;IAAA;AAChG,GACA;IAAE,GAAG,2KAAA,CAAA,sBAAA;AAAwB;AAGxB,MAAM,SAAS,CAAC;IACrB,OAAO,aAAA,GAAA,+MAAA,CAAA,UAAA,CAAA,aAAA,CAAC,2KAAA,CAAA,SAAA,EAAA;QAAY,GAAG,CAAA,GAAA,yMAAA,CAAA,gCAAA,EAA8B,UAAU,OAAO,MAAK;IAAA;AAC7E;AAEO,MAAM,SAAS,CAAC;IACrB,OAAO,aAAA,GAAA,+MAAA,CAAA,UAAA,CAAA,aAAA,CAAC,2KAAA,CAAA,SAAA,EAAA;QAAY,GAAG,CAAA,GAAA,yMAAA,CAAA,gCAAA,EAA8B,UAAU,OAAO,MAAK;IAAA;AAC7E"}},
    {"offset": {"line": 248, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}